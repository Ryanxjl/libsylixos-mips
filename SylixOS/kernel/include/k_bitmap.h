/*********************************************************************************************************
**
**                                    中国软件开源组织
**
**                                   嵌入式实时操作系统
**
**                                       SylixOS(TM)
**
**                               Copyright  All Rights Reserved
**
**--------------文件信息--------------------------------------------------------------------------------
**
** 文   件   名: k_bitmap.h
**
** 创   建   人: Han.Hui (韩辉)
**
** 文件创建日期: 2006 年 12 月 12 日
**
** 描        述: 这是系统位图表以及基本的位图操作宏。

** BUG:
2009.04.13 很多算法是从笔者大四初开始设计的, 包括结构的规划, 苦于当时水平有限, 很多没有使用面向对象的设计
           方法, 例如可以将所有的 3D MAP 设计为独立的 MAP_QUEUE 组件... :-(!
           目前只能在原有的结构上增加新的功能, 如有空闲时间, 将重构内核.
           
           (如果没有特殊说明, 以下调度器改进的基础都是基于优先级的调度机制(同优先级内允许时间片), 算法的
            时间复杂度为 O(1) <相对于需要调度的线程数量>.)
           
           嵌入式系统 SMP 多核处理器的引入, 为硬实时系统调度算法引出了诸多问题.
           
           单核系统中, 仅需要使用位图找到当前优先级最高的线程即可, 可是 SMP 实时调度器带来的问题是: 需要
           知道最高优先级的 N 个线程, N <= 处理器数量. 传统的 BITMAP 不能满足要求, 或者对于线程数量来说, 
           时间复杂度不为 O(1), 破坏了硬实时系统的"完美"性. 传统非实时系统调度器例如: linux2.6 SMP 调度器
           不能满足硬实时处理.
           
           笔者考虑很久, 目前可行的办法是将"就绪队列"和"运行队列"位图分离! 可以保持硬实时调度的所有特性:
           例如: 1. 可抢占
                 2. 基于优先级, (eg. 一个四核处理器的四个 CPU 总是运行四个最高优先级的线程).(单一就绪队列)
                 3: 调度算法<相对于线程数量>时间复杂度为 O(1).
2014.11.10 更新位图算法, 占用更小的内存空间.
*********************************************************************************************************/

#ifndef __K_BITMAP_H
#define __K_BITMAP_H

/*********************************************************************************************************
                                        位图数组
*********************************************************************************************************/

#ifdef	__LW_BITMAP
UINT8  const  _K_ucLsbBitmap[] = {
    0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};
UINT8  const  _K_ucMsbBitmap[] = {
    0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};
#else
extern UINT8  const  _K_ucLsbBitmap[];
extern UINT8  const  _K_ucMsbBitmap[];
#endif                                                                  /*  __LW_BITMAP                 */

/*********************************************************************************************************
  位图基本操作
*********************************************************************************************************/

VOID  _BitmapInit(PLW_CLASS_BMAP  pbmap);
VOID  _BitmapAdd(PLW_CLASS_BMAP   pbmap, UINT8  ucPriority);
VOID  _BitmapDel(PLW_CLASS_BMAP   pbmap, UINT8  ucPriority);
UINT8 _BitmapHigh(PLW_CLASS_BMAP  pbmap);
BOOL  _BitmapIsEmpty(PLW_CLASS_BMAP  pbmap);

/*********************************************************************************************************
  就绪位图操作
*********************************************************************************************************/

VOID  _ReadyTableAdd(PLW_CLASS_TCB  ptcb);
VOID  _ReadyTableDel(PLW_CLASS_TCB  ptcb);

#define	__ADD_RDY_MAP(ptcb)             _ReadyTableAdd(ptcb)
#define __DEL_RDY_MAP(ptcb)             _ReadyTableDel(ptcb)

#endif                                                                  /*  __K_BITMAP_H                */
/*********************************************************************************************************
  END
*********************************************************************************************************/
